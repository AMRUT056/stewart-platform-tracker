# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "matplotlib",
#     "numpy"
# ]
# ///

import matplotlib.pyplot as plt
import glob
import os
import csv
import re

def parse_custom_csv(filepath):
    """
    Parses the custom CSV format generated by the tracking script.
    
    Format quirks to handle:
    - Inputs are space-separated inside quotes: "0 0 10 0 0 0"
    - Measured positions are comma-separated: 1.2,3.4,5.6,
    - Measured orientation is in a separate quoted block at the end: "R,P,Y"
    
    Target Input Mapping (based on script): [X, Y, Z, Yaw, Roll, Pitch]
    Measured Output Mapping (based on script): [X, Y, Z, Roll, Pitch, Yaw]
    """
    
    targets = {'x': [], 'y': [], 'z': [], 'r': [], 'p': [], 'y_ang': []}
    actuals = {'x': [], 'y': [], 'z': [], 'r': [], 'p': [], 'y_ang': []}
    timestamps = []

    print(f"Reading: {filepath}")
    
    with open(filepath, 'r') as f:
        lines = f.readlines()

    # Skip header lines (starts with # or matches header string)
    start_idx = 0
    for i, line in enumerate(lines):
        if "INPUT COMMAND" in line:
            start_idx = i + 1
            break
    
    for i, line in enumerate(lines[start_idx:]):
        line = line.strip()
        if not line: continue

        try:
            # --- 1. Extract Target Command ---
            # Regex to find the first quoted string: "0 0 0 0 0 0"
            cmd_match = re.search(r'"(.*?)"', line)
            if not cmd_match: continue
            
            cmd_str = cmd_match.group(1)
            # cmd_vals = [X, Y, Z, Yaw, Roll, Pitch]
            t_vals = [float(x) for x in cmd_str.split()]
            
            if len(t_vals) < 6: continue

            # --- 2. Extract Measured Values ---
            # The line structure is roughly: "CMD",X,Y,Z,","R,P,Y"
            # We can split by `","` to isolate the chunks
            parts = line.split('","')
            
            # Middle part contains X,Y,Z (and a trailing command from the file write logic)
            # parts[0] is `"CMD` (with leading quote)
            # parts[1] is `X,Y,Z,` (or similar)
            # parts[2] is `R,P,Y"` (with trailing quote)
            
            # Robust Parsing Strategy: Find all numbers outside the first quoted block
            # But the structure is messy. Let's use the split strategy which is safer for this specific file write.
            
            # Cleaning the raw string parts
            # Remove the first element (Command)
            raw_data_str = line[len(cmd_match.group(0)):] 
            
            # Clean up quotes and split by comma
            raw_data_str = raw_data_str.replace('"', '').replace(',,', ',')
            # remove leading/trailing commas
            vals = [x for x in raw_data_str.split(',') if x.strip()]
            
            # We expect 6 floats: X, Y, Z, Roll, Pitch, Yaw
            # The script writes: X, Y, Z, (then separator), Roll, Pitch, Yaw
            if len(vals) < 6: continue
            
            m_x = float(vals[0])
            m_y = float(vals[1])
            m_z = float(vals[2])
            m_roll = float(vals[3])
            m_pitch = float(vals[4])
            m_yaw = float(vals[5])

            # --- 3. Append to Lists (With correct mapping) ---
            
            # Target Order: X, Y, Z, Yaw, Roll, Pitch
            targets['x'].append(t_vals[0])
            targets['y'].append(t_vals[1])
            targets['z'].append(t_vals[2])
            targets['y_ang'].append(t_vals[3])
            targets['r'].append(t_vals[4])
            targets['p'].append(t_vals[5])

            # Measured Order: X, Y, Z, Roll, Pitch, Yaw
            actuals['x'].append(m_x)
            actuals['y'].append(m_y)
            actuals['z'].append(m_z)
            actuals['r'].append(m_roll)
            actuals['p'].append(m_pitch)
            actuals['y_ang'].append(m_yaw)
            
            timestamps.append(i)

        except Exception as e:
            # print(f"Skipping line {i}: {e}")
            pass

    return timestamps, targets, actuals

def plot_data(timestamps, targets, actuals):
    fig, axs = plt.subplots(2, 3, figsize=(15, 10))
    fig.suptitle('Stewart Platform: Target vs Measured', fontsize=16)

    # Config: (Key, Title, Subplot Indices)
    plots = [
        ('x', 'X Position (mm/cm)', 0, 0),
        ('y', 'Y Position (mm/cm)', 0, 1),
        ('z', 'Z Position (mm/cm)', 0, 2),
        ('r', 'Roll (deg)', 1, 0),
        ('p', 'Pitch (deg)', 1, 1),
        ('y_ang', 'Yaw (deg)', 1, 2)
    ]

    for key, title, r, c in plots:
        ax = axs[r, c]
        ax.plot(timestamps, targets[key], 'r--', label='Target', linewidth=2)
        ax.plot(timestamps, actuals[key], 'b-', label='Measured', alpha=0.7)
        ax.set_title(title)
        ax.grid(True, linestyle=':', alpha=0.6)
        if r == 1: ax.set_xlabel('Sample #')
        if c == 0: ax.set_ylabel('Value')
        ax.legend()

    plt.tight_layout()
    plt.show()

def main():
    # Find latest CSV
    list_of_files = glob.glob('csv_outputs/*.csv')
    if not list_of_files:
        print("No CSV files found in csv_outputs/")
        return
    
    latest_file = max(list_of_files, key=os.path.getctime)
    print(f"Processing: {latest_file}")
    
    try:
        t, targets, actuals = parse_custom_csv(latest_file)
        if not t:
            print("No valid data found in file.")
            return
        plot_data(t, targets, actuals)
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()
